/* 
 * Unit: Braun silk expert pro 5 - IPL hair removal system.
 * MCU: CH32V003J4M6.
 * Platform: https://github.com/cnlohr/ch32v003fun
 * Purpose: change head sensor readings so the unit will emit a different IPL power,
 *  usefull because the head sensor occasionally gives low readings resulting in non treated hairs.
 * 
 * https://github.com/arduino12/braun-silk-expert-pro-mod 2024
 */
#include "ch32v003fun.h"

#define PACKET_UART_BAUDRATE		(9600)
#define PACKET_SENSOR_READ_HEADER	(5)
#define PACKET_SENSOR_READ_SIZE		(26)
#define MAX_SENSOR_READ_POWER		(10)

const uint8_t PACKET_GET_MODEL[] = {
	0x2C,0xD3,0x00,0x07,0x25,0x2C,0x5F,
};
const uint8_t PACKET_REPLY_GET_MODEL[] = {
	0x25,0xDA,0x00,0x14,0x2C,0x54,0x39,0x30,0x30,0x43,0x34,0x32,0x31,0x30,0x34,0x35,0x37,0x34,0x0E,0x31
};
const uint8_t PACKET_SET_PARAMS[] = {
	0x2C,0xD3,0x01,0x14,0x25,0x0C,0xD4,0x18,0xA4,0xC5,0x75,0xB6,0x51,0x92,0x00,0x00,0x00,0x00,0xAD,0xE2,
};
const uint8_t PACKET_REPLY_SET_PARAMS[] = {
	0x25,0xDA,0xC5,0x08,0x2C,0x01,0xFA,0xAD,
};
const uint8_t PACKET_SENSOR_READ[] = {
	0x2C,0xD3,0x24,0x1A,0x25,0x00,0x00,0x00,0x00,0x02,0x00,0x64,0x64,
	0x0A,0x0E,0x0D,0xD0,0x07,0xD0,0x07,0x00,0x00,0x2C,0x01,0x30,0xC7,
	0x2C,0xD3,0x24,0x1A,0x25,0x01,0x00,0x00,0x00,0x02,0x00,0x64,0x64,
	0x09,0x0D,0x0D,0x24,0x13,0x24,0x13,0xDC,0xDC,0x2C,0x01,0xA7,0xEE,
	0x2C,0xD3,0x24,0x1A,0x25,0x02,0x00,0x00,0x00,0x02,0x00,0x64,0x64,
	0x09,0x0D,0x0D,0x50,0x14,0x50,0x14,0xDC,0xDC,0x2C,0x01,0x03,0x78,
	0x2C,0xD3,0x24,0x1A,0x25,0x03,0x00,0x00,0x00,0x02,0x00,0x64,0x64,
	0x09,0x0D,0x0D,0x7C,0x15,0x7C,0x15,0xDC,0xDC,0x2C,0x01,0x5E,0x02,
	0x2C,0xD3,0x24,0x1A,0x25,0x04,0x00,0x00,0x00,0x02,0x00,0x64,0x64,
	0x09,0x0D,0x0D,0xA8,0x16,0xA8,0x16,0xDC,0xDC,0x2C,0x01,0xB9,0x8B,
	0x2C,0xD3,0x24,0x1A,0x25,0x05,0x00,0x00,0x00,0x02,0x00,0x64,0x64,
	0x09,0x0D,0x0D,0xD4,0x17,0xD4,0x17,0xDC,0xDC,0x2C,0x01,0x15,0x15,
	0x2C,0xD3,0x24,0x1A,0x25,0x06,0x00,0x00,0x00,0x02,0x00,0x64,0x64,
	0x09,0x0D,0x0D,0x00,0x19,0x00,0x19,0xDC,0xDC,0x2C,0x01,0x70,0x9C,
	0x2C,0xD3,0x24,0x1A,0x25,0x07,0x00,0x00,0x00,0x02,0x00,0x64,0x64,
	0x09,0x0D,0x0D,0x2C,0x1A,0x2C,0x1A,0xDC,0xDC,0x2C,0x01,0xCB,0x26,
	0x2C,0xD3,0x24,0x1A,0x25,0x08,0x00,0x00,0x00,0x02,0x00,0x64,0x64,
	0x09,0x0D,0x0D,0x58,0x1B,0x58,0x1B,0xDC,0xDC,0x2C,0x01,0x27,0xAF,
	0x2C,0xD3,0x24,0x1A,0x25,0x09,0x00,0x00,0x00,0x02,0x00,0x64,0x64,
	0x09,0x0D,0x0D,0x84,0x1C,0x84,0x1C,0xDC,0xDC,0x2C,0x01,0x82,0x39,
	0x2C,0xD3,0x24,0x1A,0x25,0x0A,0x00,0x00,0x00,0x02,0x00,0x64,0x64,
	0x09,0x0D,0x0D,0xB0,0x1D,0xB0,0x1D,0xDC,0xDC,0x2C,0x01,0xDD,0xC2,
};

volatile uint8_t packet_sensor_read_power;
volatile uint8_t packet_rx_index;

void USART1_IRQHandler(void) __attribute__((interrupt));
void USART1_IRQHandler(void)
{
	if(USART1->STATR & USART_STATR_RXNE) {
		uint8_t data = (uint8_t)USART1->DATAR;
		if (packet_rx_index < PACKET_SENSOR_READ_HEADER) {
			if (data != PACKET_SENSOR_READ[packet_rx_index++])
				packet_rx_index = 0;			
		}
		else if (packet_rx_index == PACKET_SENSOR_READ_HEADER) {
			packet_sensor_read_power = data;
			packet_rx_index = 0;
		}
	}
}

void uart_init()
{
	RCC->APB2PCENR |= RCC_APB2Periph_USART1 | RCC_APB2Periph_AFIO;

	AFIO->PCFR1 &= ~GPIO_PartialRemap2_USART1;

	USART1->CTLR1 = USART_Mode_Tx | USART_Mode_Rx;
	USART1->CTLR2 = USART1->CTLR3 = 0;
	USART1->BRR = (uint16_t)((FUNCONF_SYSTEM_CORE_CLOCK + ((PACKET_UART_BAUDRATE) / 2)) / PACKET_UART_BAUDRATE);

	USART1->CTLR1 |= USART_CTLR1_RXNEIE;
	NVIC_EnableIRQ(USART1_IRQn);
	USART1->CTLR1 |= CTLR1_UE_Set;
}

void uart_write(const uint8_t *buffer, uint8_t size)
{
	while(!(USART1->STATR & USART_FLAG_TC));
	while(size--) {
		USART1->DATAR = *buffer++;
		while(!(USART1->STATR & USART_FLAG_TC));
	}
}

int main(void)
{
	SystemInit();

	funGpioInitA();
	funGpioInitD();
	funPinMode(PA2, GPIO_CFGLR_IN_PUPD);
	funDigitalWrite(PA2, FUN_HIGH);
	funPinMode(PD5, GPIO_CFGLR_OUT_10Mhz_AF_OD);
	funPinMode(PD6, GPIO_CFGLR_OUT_10Mhz_AF_OD);

	uart_init(); // TX: PD5, RX: PD6

	Delay_Ms(20);
	uart_write(PACKET_REPLY_GET_MODEL, sizeof(PACKET_REPLY_GET_MODEL));
	Delay_Ms(25);
	uart_write(PACKET_REPLY_SET_PARAMS, sizeof(PACKET_REPLY_SET_PARAMS));
	Delay_Ms(1);
	
	AFIO->PCFR1 |= GPIO_PartialRemap2_USART1 & 0x0FFFFFFF; // TX: PD6, RX: PD5

	uart_write(PACKET_GET_MODEL, sizeof(PACKET_GET_MODEL));
	Delay_Ms(25);
	uart_write(PACKET_SET_PARAMS, sizeof(PACKET_SET_PARAMS));
	Delay_Ms(25);

	uint8_t btn_count = 0;
	uint8_t mode = 0;
	uint8_t p;
	while(1) {
		if (funDigitalRead(PA2)) {
			btn_count = 0;
			p = packet_sensor_read_power;
			if (p) {
				if (mode < 4) {
					p += mode;
					if (p > MAX_SENSOR_READ_POWER)
						p = MAX_SENSOR_READ_POWER;
				}
				else
					p = mode;
			}
		}
		else {
			if (++btn_count > 7) {
				btn_count = 3;
				if (++mode > MAX_SENSOR_READ_POWER)
					mode = 0;
			}

			p = mode;
		}
		uart_write((PACKET_SENSOR_READ + p * PACKET_SENSOR_READ_SIZE), PACKET_SENSOR_READ_SIZE);
		Delay_Ms(107-30);
	}

	return 0;
}
